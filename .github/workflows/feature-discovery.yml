name: Secrets Manager Feature Discovery

on:
  schedule:
    # Run weekly on Sundays at 00:00 UTC
    - cron: '0 0 * * 0'

  workflow_dispatch:
    inputs:
      provider_version:
        description: 'AWS Provider version to check (default: latest)'
        required: false
        default: 'latest'
        type: string
      dry_run:
        description: 'Run analysis without creating issues'
        required: false
        default: false
        type: boolean
      force_scan:
        description: 'Force full scan even if no changes detected'
        required: false
        default: false
        type: boolean

# Prevent concurrent runs to avoid race conditions in feature tracker
concurrency:
  group: secrets-manager-feature-discovery
  cancel-in-progress: false

jobs:
  discover-secrets-features:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write
      issues: write
      pull-requests: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Validate workflow inputs
        run: |
          set -euo pipefail

          # Validate provider_version parameter
          PROVIDER_VERSION="${{ inputs.provider_version || 'latest' }}"
          if [[ ! "$PROVIDER_VERSION" =~ ^(latest|[0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            echo "‚ùå Invalid provider_version format: '$PROVIDER_VERSION'"
            echo "Expected: 'latest' or semantic version (e.g., '5.82.0')"
            exit 1
          fi

          # Validate boolean inputs
          DRY_RUN="${{ inputs.dry_run }}"
          if [[ ! "$DRY_RUN" =~ ^(true|false)$ ]]; then
            echo "‚ùå Invalid dry_run value: '$DRY_RUN'"
            echo "Expected: 'true' or 'false'"
            exit 1
          fi

          FORCE_SCAN="${{ inputs.force_scan }}"
          if [[ ! "$FORCE_SCAN" =~ ^(true|false)$ ]]; then
            echo "‚ùå Invalid force_scan value: '$FORCE_SCAN'"
            echo "Expected: 'true' or 'false'"
            exit 1
          fi

          echo "‚úÖ All workflow inputs validated successfully"
          echo "- Provider version: $PROVIDER_VERSION"
          echo "- Dry run mode: $DRY_RUN"
          echo "- Force scan: $FORCE_SCAN"

      - name: Validate repository hygiene
        run: |
          set -euo pipefail

          # Check for prohibited files that should never be committed
          PROHIBITED_FILES=""

          if find . -name "*.tfstate*" -not -path "./.git/*" | grep -q .; then
            PROHIBITED_FILES="$PROHIBITED_FILES\n- Terraform state files (*.tfstate*)"
          fi

          if [ -f "package-lock.json" ] && [ ! -s "package-lock.json" ]; then
            PROHIBITED_FILES="$PROHIBITED_FILES\n- Empty package-lock.json"
          fi

          if [ -f ".env" ] || [ -f ".env.local" ]; then
            PROHIBITED_FILES="$PROHIBITED_FILES\n- Environment files (.env*)"
          fi

          # Check for accidentally committed secrets
          if find . -name "*.pem" -o -name "*.key" -o -name "*_rsa*" | grep -v "./.git/" | head -1 | grep -q .; then
            PROHIBITED_FILES="$PROHIBITED_FILES\n- Private keys or certificates (*.pem, *.key, *_rsa*)"
          fi

          if [ -n "$PROHIBITED_FILES" ]; then
            echo "‚ùå Repository hygiene check failed!"
            echo "The following prohibited files were found:"
            echo -e "$PROHIBITED_FILES"
            echo ""
            echo "Please remove these files before running the feature discovery workflow."
            exit 1
          fi

          echo "‚úÖ Repository hygiene check passed!"

      - name: Create feature tracker directory
        run: |
          set -euo pipefail

          # =============================================================================
          # FUNCTION DEFINITIONS - All functions must be defined before use
          # =============================================================================

          # Security Kernel - Centralized input validation and sanitization
          security_validate_inputs() {
            local provider_version="${1:-unknown}"
            local dry_run="${2:-false}"
            local force_scan="${3:-false}"

            # Validate provider version format
            if [[ ! "$provider_version" =~ ^(latest|[0-9]+\.[0-9]+\.[0-9]+)$ ]] && [ "$provider_version" != "unknown" ]; then
              echo "‚ö†Ô∏è Invalid provider version format: $provider_version"
              return 1
            fi

            # Validate boolean inputs
            if [[ ! "$dry_run" =~ ^(true|false)$ ]]; then
              echo "‚ö†Ô∏è Invalid dry_run value: $dry_run"
              return 1
            fi

            if [[ ! "$force_scan" =~ ^(true|false)$ ]]; then
              echo "‚ö†Ô∏è Invalid force_scan value: $force_scan"
              return 1
            fi

            echo "‚úÖ All inputs validated successfully"
            return 0
          }

          # Enhanced sanitization for template parameters with structured approach
          sanitize_template_parameter() {
            local input="$1"
            local param_type="${2:-text}"

            case "$param_type" in
              "feature_name")
                # Extra strict for feature names - only allow alphanumeric, hyphens, underscores, spaces
                echo "$input" | sed -e 's/[^a-zA-Z0-9_\- ]//g' -e 's/  */ /g' -e 's/^ *//g' -e 's/ *$//g'
                ;;
              "version")
                # Only allow version-like strings
                echo "$input" | sed -e 's/[^a-zA-Z0-9\.-]//g'
                ;;
              "date")
                # Only allow ISO date format characters
                echo "$input" | sed -e 's/[^0-9T:Z\-]//g'
                ;;
              *)
                # General markdown sanitization
                echo "$input" | sed -e 's/[<>&"]/\\&/g' -e "s/'/\\&#39;/g" -e 's/\[/\\[/g' -e 's/\]/\\]/g' -e 's/`/\\`/g'
                ;;
            esac
          }

          # Process issue template with sanitized parameters
          process_template_content() {
            local template_file="$1"
            local feature_name="$2"
            local provider_version="$3"
            local discovery_date="$4"
            local resource_type="${5:-}"
            local description="${6:-}"
            local notes="${7:-}"

            # Read template and replace placeholders with sanitized values
            sed \
              -e "s/\[FEATURE_NAME\]/$feature_name/g" \
              -e "s/\[PROVIDER_VERSION\]/$provider_version/g" \
              -e "s/\[DISCOVERY_DATE\]/$discovery_date/g" \
              -e "s/\[RESOURCE_TYPE\]/$resource_type/g" \
              -e "s/\[AUTO_GENERATED_DESCRIPTION\]/$description/g" \
              -e "s/\[AUTO_GENERATED_NOTES\]/$notes/g" \
              -e "s/\[PROVIDER_DOC_URL\]/https:\/\/registry.terraform.io\/providers\/hashicorp\/aws\/latest\/docs/g" \
              -e "s/\[AWS_DOC_URL\]/https:\/\/docs.aws.amazon.com\/secretsmanager/g" \
              "$template_file"
          }

          # Centralized timestamp authority
          get_iso_timestamp() {
            date -u +%Y-%m-%dT%H:%M:%SZ
          }

          # Organization-aware assignee resolution with validation
          determine_assignee() {
            local assignee="${{ github.actor }}"
            local repo_owner="${{ github.repository_owner }}"

            # Check if this is an organization repository
            if [ "${{ github.repository_owner_type }}" = "Organization" ]; then
              # For org repos, try to use a team or fallback to owner
              # First check if we have a designated team in repository variables
              local designated_assignee="${{ vars.FEATURE_DISCOVERY_ASSIGNEE || '' }}"
              if [ -n "$designated_assignee" ]; then
                echo "$designated_assignee"
                return 0
              fi

              # Fallback to repository owner for org repos
              assignee="$repo_owner"
            fi

            # Handle bot/scheduled runs
            if [ "${{ github.event_name }}" = "schedule" ] || [ -z "$assignee" ] || [ "$assignee" = "github-actions[bot]" ]; then
              assignee="$repo_owner"
            fi

            echo "$assignee"
          }

          # Legacy sanitize_for_markdown function (for backward compatibility)
          sanitize_for_markdown() {
            echo "$1" | sed -e 's/[<>&"]/\\&/g' -e "s/'/\\&#39;/g" -e 's/\[/\\[/g' -e 's/\]/\\]/g' -e 's/`/\\`/g'
          }

          # Atomic file operation wrapper for safe concurrent access
          atomic_file_operation() {
            local operation="$1"
            local file_path="$2"
            local content="${3:-}"
            local temp_file=$(mktemp)

            case "$operation" in
              "write")
                echo "$content" > "$temp_file" && mv "$temp_file" "$file_path"
                ;;
              "append")
                if [ -f "$file_path" ]; then
                  cp "$file_path" "$temp_file"
                fi
                echo "$content" >> "$temp_file" && mv "$temp_file" "$file_path"
                ;;
              *)
                echo "‚ùå Unsupported atomic operation: $operation"
                rm -f "$temp_file"
                return 1
                ;;
            esac
          }

          # Git configuration wrapper with proper error handling
          git_config_safe() {
            local config_key="$1"
            local config_value="$2"

            # Check if we're in a git repository
            if ! git rev-parse --git-dir >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Not in a git repository, initializing..."
              if ! git init; then
                echo "‚ùå Failed to initialize git repository"
                return 1
              fi
            fi

            # Set git configuration with error handling
            if ! git config "$config_key" "$config_value"; then
              echo "‚ùå Failed to configure git $config_key"
              return 1
            fi

            echo "‚úÖ Git configuration set: $config_key = $config_value"
            return 0
          }

          # =============================================================================
          # MAIN EXECUTION - Functions are now defined and can be safely called
          # =============================================================================

          # Create directory with error handling
          if ! mkdir -p .github/feature-tracker; then
            echo "‚ùå Failed to create feature tracker directory"
            exit 1
          fi

          # Validate workflow inputs using security kernel
          if ! security_validate_inputs "${{ inputs.provider_version || 'latest' }}" "${{ inputs.dry_run }}" "${{ inputs.force_scan }}"; then
            echo "‚ùå Input validation failed"
            exit 1
          fi

          # Create initial tracker file if it doesn't exist (atomic creation)
          if [ ! -f .github/feature-tracker/secrets-manager-features.json ]; then
            # Create temporary file for atomic write
            TEMP_FILE=$(mktemp)

            # Get current timestamp for initial values using centralized authority
            INITIAL_TIMESTAMP="$(get_iso_timestamp)"

            # Write content to temporary file
            cat > "$TEMP_FILE" << EOF
          {
            "metadata": {
              "module_name": "terraform-aws-secrets-manager",
              "last_scan": "$INITIAL_TIMESTAMP",
              "provider_version": "unknown",
              "scan_count": 0
            },
            "scan_history": [],
            "current_implementation": {
              "resources": {
                "aws_secretsmanager_secret": {
                  "implemented": [
                    "name",
                    "description",
                    "kms_key_id",
                    "policy",
                    "recovery_window_in_days",
                    "force_overwrite_replica_secret",
                    "replica",
                    "tags"
                  ],
                  "pending": [],
                  "deprecated": []
                },
                "aws_secretsmanager_secret_version": {
                  "implemented": [
                    "secret_id",
                    "secret_string",
                    "secret_binary",
                    "version_stages"
                  ],
                  "pending": [],
                  "deprecated": []
                },
                "aws_secretsmanager_secret_rotation": {
                  "implemented": [
                    "secret_id",
                    "rotation_lambda_arn",
                    "rotation_rules"
                  ],
                  "pending": [],
                  "deprecated": []
                },
                "aws_secretsmanager_secret_policy": {
                  "implemented": [
                    "secret_arn",
                    "policy",
                    "block_public_policy"
                  ],
                  "pending": [],
                  "deprecated": []
                }
              },
              "data_sources": {
                "aws_secretsmanager_secret": {
                  "implemented": [
                    "name",
                    "arn"
                  ],
                  "pending": [],
                  "deprecated": []
                },
                "aws_secretsmanager_secret_version": {
                  "implemented": [
                    "secret_id",
                    "version_id",
                    "version_stage"
                  ],
                  "pending": [],
                  "deprecated": []
                },
                "aws_secretsmanager_secrets": {
                  "implemented": [
                    "filter"
                  ],
                  "pending": [],
                  "deprecated": []
                }
              },
              "examples": {
                "complete": {
                  "resources": [
                    "aws_secretsmanager_secret",
                    "aws_secretsmanager_secret_version",
                    "aws_secretsmanager_secret_rotation",
                    "aws_secretsmanager_secret_policy"
                  ]
                },
                "basic": {
                  "resources": [
                    "aws_secretsmanager_secret",
                    "aws_secretsmanager_secret_version"
                  ]
                },
                "rotation": {
                  "resources": [
                    "aws_secretsmanager_secret",
                    "aws_secretsmanager_secret_version",
                    "aws_secretsmanager_secret_rotation"
                  ]
                }
              }
            },
            "discovered_features": {
              "new_resources": {},
              "new_arguments": {},
              "new_data_sources": {},
              "deprecated_items": {},
              "bug_fixes": {}
            },
            "issues_created": [],
            "failed_issues": [],
            "statistics": {
              "total_scans": 0,
              "total_features_discovered": 0,
              "total_issues_created": 0,
              "total_failed_issues": 0,
              "average_features_per_scan": 0,
              "last_feature_discovery": "$INITIAL_TIMESTAMP",
              "last_failure_timestamp": null
            }
          }
          EOF

            # Atomic move to final location
            if ! mv "$TEMP_FILE" .github/feature-tracker/secrets-manager-features.json; then
              echo "‚ùå Failed to create feature tracker file"
              rm -f "$TEMP_FILE"
              exit 1
            fi

            echo "‚úÖ Created initial feature tracker file"
          fi

      - name: Run Claude Code Feature Discovery
        id: claude-discovery
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}

          # MCP Configuration for Terraform and Context7 documentation access
          mcp_config: |
            {
              "mcpServers": {
                "terraform": {
                  "command": "npx",
                  "args": [
                    "-y",
                    "@modelcontextprotocol/server-terraform@latest"
                  ]
                },
                "context7": {
                  "command": "npx",
                  "args": [
                    "-y",
                    "@upstash/context7-mcp@latest"
                  ]
                }
              }
            }

          # Allow necessary tools for feature discovery
          allowed_tools: |
            mcp__terraform-server__getProviderDocs
            mcp__terraform-server__resolveProviderDocID
            mcp__terraform-server__searchModules
            mcp__terraform-server__moduleDetails
            mcp__context7__resolve-library-id
            mcp__context7__get-library-docs
            Bash(git diff)
            Bash(git status)
            Bash(gh issue create)
            Bash(gh issue list)
            Bash(jq)
            Bash(cat)
            Bash(echo)

          # Direct prompt for Claude Code to perform feature discovery
          direct_prompt: |
            # Secrets Manager Feature Discovery Analysis

            You are performing automated feature discovery for the terraform-aws-secrets-manager module.

            ## Objective
            Analyze the latest AWS provider Secrets Manager resources and compare them with the current module implementation to identify:
            1. **New Features**: Secrets Manager resources/arguments not yet implemented
            2. **Deprecations**: Features marked as deprecated in the provider
            3. **Bug Fixes**: Important fixes mentioned in provider changelogs

            ## Configuration
            - Provider Version: ${{ inputs.provider_version || 'latest' }}
            - Dry Run Mode: ${{ inputs.dry_run }}
            - Force Scan: ${{ inputs.force_scan }}

            ## Process

            ### Step 1: Load Current State
            Read the feature tracking database:
            ```bash
            cat .github/feature-tracker/secrets-manager-features.json
            ```

            ### Step 2: Fetch AWS Provider Secrets Manager Documentation
            Use the Terraform MCP server to get the latest Secrets Manager documentation:

            1. Use `mcp__terraform-server__resolveProviderDocID` with:
               - providerName: "aws"
               - providerNamespace: "hashicorp"
               - serviceSlug: "secretsmanager"
               - providerVersion: "${{ inputs.provider_version || 'latest' }}"
               - providerDataType: "resources"

            2. Get documentation for all Secrets Manager resources (aws_secretsmanager_*)
            3. Also check data sources with providerDataType: "data-sources"

            ### Step 3: Analyze Current Module Implementation
            Examine these files to understand current implementation:
            - `main.tf` - Primary secrets manager resources
            - `data.tf` - Data source definitions
            - `variables.tf` - Input variables
            - `outputs.tf` - Module outputs
            - `examples/` directory structure (binary, complete, key-value, plaintext, replication, rotation, ephemeral)

            Create an inventory of:
            - Implemented resources (aws_secretsmanager_secret, aws_secretsmanager_secret_version, etc.)
            - Implemented arguments/attributes on each resource
            - Configuration patterns used in examples

            ### Step 4: Comparison and Analysis
            Compare provider documentation with module implementation:

            **New Features to Look For:**
            - New `aws_secretsmanager_*` resources not in the module
            - New arguments on existing resources (secret, version, rotation, etc.)
            - New data sources (`data.aws_secretsmanager_*`)
            - New rotation and lifecycle features
            - New replication and cross-region capabilities
            - New security and encryption options
            - New ephemeral secrets features
            - New integration capabilities (Lambda, RDS, etc.)

            **Deprecations to Check:**
            - Arguments marked as deprecated
            - Resources marked for removal
            - Rotation patterns no longer recommended
            - Configuration approaches that are outdated

            **Bug Fixes:**
            - Check Context7 for AWS provider changelogs
            - Look for Secrets Manager-related fixes that might affect the module

            ### Step 5: Issue Creation
            For each significant finding:

            **IMPORTANT: Sanitization Requirements**
            - Sanitize feature names before inserting into templates
            - Escape special characters in descriptions and titles
            - Replace [feature_name] with actual feature names (no brackets)
            - Ensure all template placeholders are properly filled
            - Avoid injection attacks by cleaning markdown/HTML in feature descriptions

            **If NOT in dry run mode (${{ inputs.dry_run }} == false):**

            Create GitHub issues using templates with proper error handling:

            ```bash
            # Get assignee with fallback
            ASSIGNEE=$(determine_assignee)

            # For new features - with enhanced structured sanitization
            if [ -n "$FEATURE_NAME" ]; then
              SAFE_FEATURE_NAME=$(sanitize_template_parameter "$FEATURE_NAME" "feature_name")
              SAFE_DESCRIPTION=$(sanitize_template_parameter "$FEATURE_DESCRIPTION" "text")
              SAFE_PROVIDER_VERSION=$(sanitize_template_parameter "${{ inputs.provider_version || 'latest' }}" "version")
              DISCOVERY_DATE=$(get_iso_timestamp)

              # Process template with sanitized parameters
              ISSUE_BODY=$(process_template_content \
                ".github/ISSUE_TEMPLATE/new-secrets-feature.md" \
                "$SAFE_FEATURE_NAME" \
                "$SAFE_PROVIDER_VERSION" \
                "$DISCOVERY_DATE" \
                "aws_secretsmanager_secret" \
                "$SAFE_DESCRIPTION" \
                "Automatically discovered by feature discovery workflow")

              if ! ERROR_OUTPUT=$(gh issue create \
                --body "$ISSUE_BODY" \
                --title "feat: Add support for $SAFE_FEATURE_NAME" \
                --label "enhancement,aws-provider-update,auto-discovered" \
                --assignee "$ASSIGNEE" 2>&1); then

                echo "‚ö†Ô∏è Failed to create feature issue - storing in tracker for manual creation"

                # Transactional update of tracker with failed issue details
                update_failed_issue_stats() {
                  local issue_type="$1"
                  local issue_title="$2"
                  local issue_labels="$3"
                  local issue_assignee="$4"
                  local error_msg="$5"

                  local TRACKER_FILE=".github/feature-tracker/secrets-manager-features.json"
                  local TEMP_FILE=$(mktemp)
                  local FAILURE_TIMESTAMP=$(get_iso_timestamp)

                  # Atomically update both failed_issues array and statistics
                  if jq --arg type "$issue_type" \
                        --arg title "$issue_title" \
                        --arg labels "$issue_labels" \
                        --arg assignee "$issue_assignee" \
                        --arg error "$error_msg" \
                        --arg timestamp "$FAILURE_TIMESTAMP" \
                        '
                        .failed_issues += [{
                          "type": $type,
                          "title": $title,
                          "labels": $labels,
                          "assignee": $assignee,
                          "error_message": $error,
                          "failure_timestamp": $timestamp,
                          "retry_count": 0
                        }] |
                        .statistics.total_failed_issues += 1 |
                        .statistics.last_failure_timestamp = $timestamp
                        ' "$TRACKER_FILE" > "$TEMP_FILE"; then
                    mv "$TEMP_FILE" "$TRACKER_FILE"
                    echo "‚úÖ Updated failed issue statistics"
                  else
                    echo "‚ùå Failed to update tracker statistics"
                    rm -f "$TEMP_FILE"
                  fi
                }

                update_failed_issue_stats "feature" "feat: Add support for $SAFE_FEATURE_NAME" \
                  "enhancement,aws-provider-update,auto-discovered" "$ASSIGNEE" "$ERROR_OUTPUT"
              fi
            fi

            # For deprecations - with enhanced structured sanitization
            if [ -n "$DEPRECATED_FEATURE" ]; then
              SAFE_DEPRECATED_NAME=$(sanitize_template_parameter "$DEPRECATED_FEATURE" "feature_name")
              DISCOVERY_DATE=$(get_iso_timestamp)

              # Process template with sanitized parameters
              ISSUE_BODY=$(process_template_content \
                ".github/ISSUE_TEMPLATE/secrets-deprecation.md" \
                "$SAFE_DEPRECATED_NAME" \
                "$SAFE_PROVIDER_VERSION" \
                "$DISCOVERY_DATE" \
                "deprecated" \
                "This feature has been deprecated in the AWS provider" \
                "Review migration path and update module accordingly")

              if ! ERROR_OUTPUT=$(gh issue create \
                --body "$ISSUE_BODY" \
                --title "chore: Handle deprecation of $SAFE_DEPRECATED_NAME" \
                --label "deprecation,breaking-change,auto-discovered" \
                --assignee "$ASSIGNEE" 2>&1); then

                echo "‚ö†Ô∏è Failed to create deprecation issue - storing in tracker for manual creation"

                update_failed_issue_stats "deprecation" "chore: Handle deprecation of $SAFE_DEPRECATED_NAME" \
                  "deprecation,breaking-change,auto-discovered" "$ASSIGNEE" "$ERROR_OUTPUT"
              fi
            fi

            # For bug fixes - with enhanced structured sanitization
            if [ -n "$BUG_DESCRIPTION" ]; then
              SAFE_BUG_DESCRIPTION=$(sanitize_template_parameter "$BUG_DESCRIPTION" "feature_name")
              DISCOVERY_DATE=$(get_iso_timestamp)

              # Process template with sanitized parameters
              ISSUE_BODY=$(process_template_content \
                ".github/ISSUE_TEMPLATE/secrets-bug-fix.md" \
                "$SAFE_BUG_DESCRIPTION" \
                "$SAFE_PROVIDER_VERSION" \
                "$DISCOVERY_DATE" \
                "bug_fix" \
                "This bug was discovered during automated provider analysis" \
                "Requires immediate attention for module reliability")

              if ! ERROR_OUTPUT=$(gh issue create \
                --body "$ISSUE_BODY" \
                --title "fix: Address $SAFE_BUG_DESCRIPTION" \
                --label "bug,aws-provider-update,auto-discovered" \
                --assignee "$ASSIGNEE" 2>&1); then

                echo "‚ö†Ô∏è Failed to create bug fix issue - storing in tracker for manual creation"

                update_failed_issue_stats "bug_fix" "fix: Address $SAFE_BUG_DESCRIPTION" \
                  "bug,aws-provider-update,auto-discovered" "$ASSIGNEE" "$ERROR_OUTPUT"
              fi
            fi
            ```

            ### Step 6: Update Feature Tracker
            Update `.github/feature-tracker/secrets-manager-features.json` with:
            - Current scan timestamp
            - Provider version analyzed
            - New findings
            - Issues created
            - Scan summary

            ### Step 7: Generate Summary Report
            Create a comprehensive summary including:
            - Features discovered: count and details
            - Deprecations found: count and impact
            - Issues created: numbers and links
            - Recommendations for next steps

            ## Important Notes
            - Skip creating issues for features already tracked as "implemented"
            - Check existing GitHub issues to avoid duplicates
            - Prioritize security, rotation, and replication changes
            - Focus on Secrets Manager-specific features (ignore general AWS provider changes)
            - Pay special attention to secret management, rotation, and ephemeral secrets
            - Consider cross-region replication and compliance features
            - Look for improvements to secret lifecycle management

            ## Expected Output
            Provide a detailed report of your analysis and actions taken.

      - name: Handle Claude Code errors
        if: steps.claude-discovery.conclusion == 'failure'
        run: |
          echo "‚ùå Claude Code feature discovery failed"
          echo "This may be due to:"
          echo "- MCP server connectivity issues"
          echo "- Terraform registry API limitations"
          echo "- Provider documentation parsing errors"
          echo "- GitHub API rate limiting"
          echo ""
          echo "Check the logs above for specific error details."
          echo "Consider running the workflow again or using manual mode."

      - name: Commit feature tracker updates
        if: steps.claude-discovery.conclusion == 'success'
        run: |
          set -euo pipefail

          # =============================================================================
          # FUNCTION DEFINITIONS - Required functions for this step
          # =============================================================================

          # Centralized timestamp authority
          get_iso_timestamp() {
            date -u +%Y-%m-%dT%H:%M:%SZ
          }

          # Git configuration wrapper with proper error handling
          git_config_safe() {
            local config_key="$1"
            local config_value="$2"

            # Check if we're in a git repository
            if ! git rev-parse --git-dir >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Not in a git repository, initializing..."
              if ! git init; then
                echo "‚ùå Failed to initialize git repository"
                return 1
              fi
            fi

            # Set git configuration with error handling
            if ! git config "$config_key" "$config_value"; then
              echo "‚ùå Failed to configure git $config_key"
              return 1
            fi

            echo "‚úÖ Git configuration set: $config_key = $config_value"
            return 0
          }

          # Atomic lease-based file locking with race condition protection
          acquire_tracker_lock() {
            local LOCK_FILE=".github/feature-tracker/.lock"
            local LOCK_TIMEOUT=300  # 5 minutes
            local LEASE_DURATION=600  # 10 minutes
            local CURRENT_TIME=$(date +%s)
            local PROCESS_ID=$$
            local LOCK_CONTENT="${CURRENT_TIME}:${PROCESS_ID}:${{ github.run_id }}"

            echo "üîê Attempting to acquire tracker lock..."

            # Atomic check-and-set operation using link (atomic on most filesystems)
            local ATTEMPT=0
            local MAX_ATTEMPTS=60  # 5 minutes with 5-second intervals

            while [ "$ATTEMPT" -lt "$MAX_ATTEMPTS" ]; do
              # Create temporary file with lock content
              local TEMP_LOCK_FILE=$(mktemp "${LOCK_FILE}.XXXXXX")
              echo "$LOCK_CONTENT" > "$TEMP_LOCK_FILE"

              # Try to atomically create lock file using link (atomic on most filesystems)
              if ln "$TEMP_LOCK_FILE" "$LOCK_FILE" 2>/dev/null; then
                # Successfully acquired lock, clean up temporary file
                rm -f "$TEMP_LOCK_FILE"

                echo "üîí Acquired tracker lock (PID: $PROCESS_ID, expires in ${LEASE_DURATION}s)"

                # Set trap to release lock on exit
                trap "rm -f '$LOCK_FILE' 2>/dev/null || true" EXIT
                return 0
              fi

              # Failed to acquire lock, clean up temporary file
              rm -f "$TEMP_LOCK_FILE"

              # Lock directory exists, check if existing lock is expired
              if [ -f "$LOCK_FILE" ]; then
                local LOCK_INFO=$(cat "$LOCK_FILE" 2>/dev/null || echo "0:0:unknown")
                local LOCK_TIME=$(echo "$LOCK_INFO" | cut -d: -f1)
                local LOCK_PID=$(echo "$LOCK_INFO" | cut -d: -f2)
                local LOCK_RUN=$(echo "$LOCK_INFO" | cut -d: -f3)
                local LOCK_AGE=$((CURRENT_TIME - LOCK_TIME))

                if [ "$LOCK_AGE" -ge "$LEASE_DURATION" ]; then
                  echo "üîì Found expired lock (age: ${LOCK_AGE}s, PID: $LOCK_PID, run: $LOCK_RUN)"

                  # Attempt to claim expired lock atomically
                  if mkdir "${LOCK_FILE}.cleanup" 2>/dev/null; then
                    rm -f "$LOCK_FILE"
                    rmdir "${LOCK_FILE}.cleanup"
                    continue  # Try to acquire again
                  fi
                fi

                if [ "$((ATTEMPT % 12))" -eq 0 ]; then  # Log every minute
                  echo "‚è≥ Waiting for lock held by PID $LOCK_PID (run: $LOCK_RUN, age: ${LOCK_AGE}s)..."
                fi
              else
                # Lock file disappeared, try again
                continue
              fi

              ATTEMPT=$((ATTEMPT + 1))
              sleep 5
            done

            echo "‚ùå Failed to acquire lock after $((MAX_ATTEMPTS * 5)) seconds"
            return 1
          }

          # Acquire lock before proceeding
          if ! acquire_tracker_lock; then
            echo "‚ùå Failed to acquire tracker lock, aborting updates"
            exit 1
          fi

          # Check if there are changes to commit
          if git diff --quiet .github/feature-tracker/; then
            echo "‚úÖ No changes to feature tracker detected"
            exit 0
          fi

          # Prepare secure commit message variables using centralized timestamp
          SCAN_TIMESTAMP="$(get_iso_timestamp)"
          PROVIDER_VERSION="${{ inputs.provider_version || 'latest' }}"

          # Configure git with safe error handling
          if ! git_config_safe "user.name" "Secrets Manager Feature Discovery Bot"; then
            echo "‚ùå Failed to configure git user name"
            exit 1
          fi

          if ! git_config_safe "user.email" "actions@github.com"; then
            echo "‚ùå Failed to configure git user email"
            exit 1
          fi

          # Add changes with error handling
          if ! git add .github/feature-tracker/; then
            echo "‚ùå Failed to stage feature tracker changes"
            exit 1
          fi

          # Commit changes with secure message
          if ! git commit -m "chore: update Secrets Manager feature discovery tracker

          - Updated feature tracking database
          - Scan completed: ${SCAN_TIMESTAMP}
          - Provider version: ${PROVIDER_VERSION}

          [skip ci]"; then
            echo "‚ùå Failed to commit feature tracker changes"
            exit 1
          fi

          # Push changes with error handling
          if ! git push origin HEAD; then
            echo "‚ùå Failed to push feature tracker changes"
            exit 1
          fi

          echo "‚úÖ Feature tracker updated successfully"

      - name: Workflow Summary
        if: always()
        run: |
          echo "## üîç Secrets Manager Feature Discovery Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Configuration
          echo "### ‚öôÔ∏è Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Provider Version**: \`${{ inputs.provider_version || 'latest' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Dry Run Mode**: \`${{ inputs.dry_run }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Force Scan**: \`${{ inputs.force_scan }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered**: \`${{ github.event_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # MCP Configuration
          echo "### üîó MCP Servers" >> $GITHUB_STEP_SUMMARY
          echo "- **Terraform MCP**: \`@modelcontextprotocol/server-terraform@latest\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Context7 MCP**: \`@upstash/context7-mcp@latest\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Status
          echo "### üìä Execution Status" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ **Repository Hygiene**: Passed validation" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.claude-discovery.conclusion }}" = "success" ]; then
            echo "- ‚úÖ **Feature Discovery**: Completed successfully" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ **Feature Tracker**: Updated with latest scan results" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.claude-discovery.conclusion }}" = "failure" ]; then
            echo "- ‚ùå **Feature Discovery**: Failed (see error handling step for details)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚è≠Ô∏è **Feature Tracker**: Skipped due to discovery failure" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚è≥ **Feature Discovery**: In progress or skipped" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Available Commands
          echo "### üöÄ Manual Execution" >> $GITHUB_STEP_SUMMARY
          echo "Run feature discovery manually:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Standard discovery" >> $GITHUB_STEP_SUMMARY
          echo "gh workflow run feature-discovery.yml" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Dry run mode" >> $GITHUB_STEP_SUMMARY
          echo "gh workflow run feature-discovery.yml -f dry_run=true" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Specific provider version" >> $GITHUB_STEP_SUMMARY
          echo "gh workflow run feature-discovery.yml -f provider_version=5.82.0" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
